# OSI7 계층, HTTP 

> 네트워크 통신을 쉽게 이해할 수 있도록 계층을 나눈 개념 (층이 7개)
> 각 계층이 역할을 가지고 계층간의 데이터를 주고받기 위해서 네트워크 통신을 단계별로 나눈 것 

> 물데네전세표응 *****💡

1. 물리계층 (하드웨어)
> 두 컴퓨터가 있다고 가정하면,  
> 컴퓨터는 파일이나 프로그램들이 모두 0 과 1
> 0과 1로 관리한다.
> 두 컴퓨터는 통신을 하기 위해서 전기신호, 전자기파 등을 사용해서 데이터를 표현하고 전달해야한다.
> 0101 => 아날로그 신호로 변환해서(인코드) ---> 디지털 신호 (0과 1 값으로 변환)로 복원해서 데이터를 받을 수 있다. (디코드)

> 배달을 한다고 가정하면, 물리계층은 도로의 역할

2. 데이터 링크 계층(하드웨어)
> 같은 네트워크에 있는 여러대의 컴퓨터가 데이터를 주고받을 수 있도록 한다.
> 스위치: 네트워크에 있는 데이터를 전송하는 하드웨어 
> 브리지: 네트워크 연결해서 데이터의 흐름을 관리한다.
> 랜카드: 컴퓨터와 네트워크를 연결하는 하드웨어
> MAC 주소 : 네트워크의 장치의 고유 주소

> 배달을 하는 기사가 도로를 통해 배달을 하면서 차선 등을 옮겨다니며 신호등을 보고 사고가 안나게 배달을 진행하는 것 

3. 네트워크 계층(소프트웨어 + 하드웨어)
> IP 주소를 사용해서 데이터를 목적지 즉 컴퓨터로 전송한다.
> 라우터 : 네트워크의 패킷을 라우팅하는 하드웨어, IP 주소를 기반으로 데이터를 전송한다.
> DNS (공부 필요)
> IP 주소 : 인터넷에서 장치간의 통신을 위해 사용하는 고유의 주소

> 배달기사가 주소를 보고 목적지까지 배달을 하는 과정

4. 전송 계층(스프트웨어)
> 포트 번호를 사용해서 데이터를 받은 컴퓨터의 최종 목적지 프로세스까지 도달 하도록 한다.
> 운영체제의 커널에 구현되어있다.

5. 세션 계층(소프트웨어)
> 세션을 설정하고 관리하고 유지
> 로그인 유지나 동기화

6. 표현계층
> 데이터의 인코딩 디코딩 압축이나 암호화를 한다
> 데이터 포멧 GIF, JPEG 등의 변환
> 암호화 : /ssl 등의 보안

7. 응용계층
> 유저가 직접 인터넷을 이용하는 것, 상호작용을 하는 계층
> 웹 서비스 : API 통신 이메일 전송 파일 전송

### OSI7 모댈과 TCP/IP 모델
> 이전에는 OSI7계층 모델을 주로 사용했는데
> 현재는 인터넷이 TCP/IP 모델을 더 많이 사용하게 되었다.
> 시장 점유 싸움에서 밀려서 TCP/IP가 더 우세했다. 

### TCP/IP (OSI7계층이 압축된것)
> 기존 TCP모델은 4계층으로 
1. 네트워크 엑세스 계층 : 물리계층, 데이터 링크계층
2. 인터넷 계층 : IP 주소 기반의 데이터 전달
3. 전송계층 : TCP/UDP 신뢰성이 있는 데이터를 전송
4. 응용계층 : HTTP 등의 프로토콜을 제공

### TCP/IP 업데이트 모델
1. 네트워크 인터페이스 계층 : 물리적 전송 매체 등과 하드웨어(이더넷 wifi 등 포함)
2. 인터넷 계층 : IP 주소 기반 패킷 전달 IPv4
3. 전송계층 :TCP UDP 등을 지원
4. 응용계층 : HTTP 웹 소켓 등 

### TCP와 UDP 
> `프로토콜` 네트워크에서 데이터를 전송 즉 요청 응답을 하기 위해서 규칙을 정한 것.
> OSI 모델의 4계층 전송 계층에 해당한다.

### TCP 
> 데이터 전송 이전 두 장치가 안정적인 논리적 연결을 했는지 검사하는 프로토콜

### UDP (비연결성)
> 데이터의 전송. 논리적 연결을 하지 않고 데이터 전송을 지향하는 프로토콜 
( 영상 스트리밍 게임 등 같은 짧은 대기시간 빠른 속도가 필요한 곳에 사용 )

### TCP
### 3-way-handshacke(연결이 발생할때 일어나는 일)
> 클라이언트가 서버로 요청을 보내면 준비를 하는 단계
> 데이터를 주고받기 위해서 검증을 하는 것 검증이 되면 논리적으로 연결이 되었다.
1. SYN 전송
> 클라이언트가 서버에 준비됐니? 
> SYN 패킷을 보낸다.

2. SYN - ACK 응답 
> 서버에서 클라이언트에게 나도 준비됐어
> 서버에서는 SYN-ACK의 패킷을 보낸다. 

3. ACK 전송 
> 클라이언트는 서버에게 메세지를 받아서 나 잘 받았어 우리 이제 데이터를 주고받자.
> 논리적 연결이 되는 시점

## 예시
> 클라이언트 -> 서버 : SYN 패킷 
> 서버 -> 클라이언트 : SYN + ACK 
> 클라이언트 -> : ACK
> 논리적 연결이 된 상태. 데이터를 안전하게 전송할 준비가 끝났다. 

> 데이터를 전송 하는 과정이 일어난다.

### 4-way-handshacke(연결이 종료될때 일어나는 일)
> 논리적 연결을 끊는다.
1. FIN 전송
> 클라이언트에서 이제 논리적 연결을 종료하자
> 나 이제 끊을건데 너 데이터 다 보냈니?

2. ACK 응답 
> 서버 나 아직 응답할게 남아있어
> 데이터를 전송하지 못했으면 다 처리

3. FIN 전송
> 서버에서 클라이언트에게 데이터를 다 보냈고, 준비됐다.

4. ACK 응답 
> 서버가 응답을 받고 나 확인 완전히 종료

### 한줄 요약
> 3-way-handshacke는 논리적 연결 시작 4-way-handshacke 연결 종료 
> 데이터를 네트워크에서 주고받을때 TCP 연결 지향 방식으로 데이터를 주고받는다.

### 뱌이너리 데이터
> 사람이 숫자를 셀때 10까지 세는 이유는 손가락이 10개니까 
> 컴퓨터는 전기가 들어왔다 들어오지않았다.
> 이진수 구하는 공식 2로 나누면서 나머지 값을 모두 정렬하면 이진수로 표현된다.
> 이진수는 자리수가 올라가는 때는 1에서 값이 증가하면 자리수가 증가. 2의 값 마다 자리수가 증가한다. 
> 이진수는 0~1 -> 이후 자리수 증가 10

> 1000 이라는 이진수가 있으면 2진수의 하나의 자리수당 비트
> 4비트 `바이트 패딩`
> 컴퓨터가 사용하는 단위 => 비트 
> 이 비트가 8개가 모이면 바이트라는 컴퓨터의 가장 기본 단위가 된다.

### binary Data
> 컴퓨터는 기본 0과 1을 표현하고
> 우리는 데이터를 표현할때 비트나 바이트라는 단위를 많이 사용한다.
> 데이터의 가지수를 표현할때 사용하는 방법 이라고 보면 된다.
> 12라는 값을 저장해줘 저장하면 1은알고 2는 모르는 친구, 이진수로 변환 1100 이런식으로 저장 
> 숫자 문제 발생 글자는?
> a 라는 글자를 이진수로 표현을 어떻게 하지? 
> `character set 문자집합`  keycode : 컴퓨터는 A와 a가 다르게 받아들인다.
> 영어 문자도 숫자로 표현
> A는 65, a 97을 이진수로 변환해서 저장
> 사람이 정해놨기 때문에 `문자 집합`
> 문자집합 : 문자를 숫자로 표현할 수 있도록 정의한 규칙

### ASCII CODE
> 글자를 표현할때 8bit만 사용한다. 1byte
> 8bit중에서 1bit는 오류 체크 용도로 실제로 사용은 7bit
> 1 bit는 오류 체크용으로 사용하고 `Parity bit(페리티 비트)`
> 0000000~11111111 즉 2^7 ===128까지의 아스키 코드는 128가지의 글자를 표현할 수 있게된 것.
> 한글을 제외한 키보드의 자판에 있는 영어와 특수문자만 표현이 가능하다.
> 한글은 1byte로는 표현이 불가능 알파벳은 1글자 한글은 1자음으로는 표현할 수 없기 때문에 

### 유니코드 
> 유니코드는 전세계의 문자를 일관되게 표현할수 있도록 설계한 표준
> 아스키 코드와 유니코드의 큰 차이점은 용량의 차이가 있다.
> 글자는 하나당 1byte가 아닌 2byte를 사용한다.

### 16진수
> 2진수와 10진수
> 문자의 길이가 너무 길어서 2진수로 표현하면 비효율적 너무 길다. 16진수로 표현을 하자.
> 16진수를 구하는 식은 
> 1 2 3 4 5 6 7 8 9 A B C D E F 자리수 증가
> 10진수를 16으로 나누고 나머지를 16진수로 표현 나눈 몫을 0이 될때까지 반복
> 30 -> 1E 

### 인코딩의 규칙 
> 문자를 숫자로 나타내는것의 규칙이 있는 것처럼 
> 숫자를 바이너리 데이터로 나타내는 규칙이 있다.
> A는 숫자 65 -> 이진수로 표현하면 1000001으로 표현이 된다.
> A12를 컴퓨터가 2진진수로  표현하면 10000011100 << 이렇게 변환을 해서 저장한다.
> 컴퓨터는 어디서 잘라야할지 몰라 몇글자를 잘라야하나 
> 1000 001100 결과물이 달라질수있다.
> 앞을 8bit씩 뒤를 4bit씩 잘라야 'A12'를 만들 수 있는데
> 그래서 우리는 이런 값을 `문자 인코딩`을 하는 것 
> 문자 인코딩 중 하나인 UTF8 => 8의 숫자가 바로 bit를 나타내는 것
> 12라는 숫자는 4bit로 표현이 가능한데, 문자는 인코딩을 통해서 8bit로 변환을 해야한다. 
> 변환하는건 어려운게 아니고 단순하게 4자리의 숫자를 8자리의 숫자로 표현을 해놓으면 끝
> 0000+1100 자리수를 0으로 채워주는 것. 12 == 1000001 00001100  숫자도 문자 인코딩을 통해서 같이 표현이 가능

1. A 
> A -> 문자집합 -> 65 -> 1000001(이진수) -> 01000001(문자 인코딩)

2. 12
> 12 -> 1100(이진수) -> 00001100(문자 인코딩)

> 반대로 값을 호출하면 디코딩 




